===============================================================================
Important routines:
_______________________________________________________________________________
NOTES

-- Don't forget exceptions (including appropriate custom exceptions) and
   assertions.
-- What is missing from this is the ability to track integrated quantites and
   plot them with the 2D image.  Here are several ideas to deal with this:
   -- Don't construct a matplotlib figure, save it, and dump it; instead
      generate a matplotlib axis and return it, then let the master routine
      combine it or not with other axes before plotting.
   -- Include more information for integrated quantities in the Movie class and
      construct the appropriate panels along with the 2D image.
   -- Make the images as described below and force the user to use montage or
      some similar utility to combine with other images (generated separately).
_______________________________________________________________________________
Make movies

Take as arguments:
-- A list of DUMSES output_*/ file names
-- A list of instances of Movie

The basic idea is to loop over the output_*/ files specifies and construct the
frames for each output_*/ as described in the list of Movie instances.  An
important sanity check is that all of the Movie.name_stub values should be
unique within the given list.  This routine should also (if appropriate) encode
the frame images into a movie

This boils down to a sanity check (uniqueness of Movie.name_stub values) and a
double loop to generate individual frames (frame making should be abstracted
out to another routine), and movie encoding (including appropriate checks).

NOTE: For development of parallel version, the movie encoding should be a
different routine.  That way each process can compute a subset of the frames by
operating on a subset of the output_*/ files and generating the frames for each
movie from that output_*/ file.  Then a different routine will wait for all of
these frame-making routines to finish and will then call a routine to encode
the frames into movies.

NOTE: Another sanity check: make sure all variables and modes exist in
SimulationState.known_variables and SimulationState.known_modes respectively.
_______________________________________________________________________________
Make a frame

Take as an argument:
-- The name of an output_*/ file
-- An instance of the Movie class

In order to be generic, this routine will create a new matplotlib figure, get
the axes for a subplot, then call another routine that will generate the 2D
image.  FOr the current design of the system, this merely adds yet another
layer that's not really helpful.  However, for future development, this gives
us flexibility.  For example, I could expand the description mechanism to allow
a description of two side-by-side plots, and it would be easy to modify this
routine to create two subplots instead of one and call the 2D plotter routine
twice with the different image descriptions.

An important part of this routine is to repackage the DumsesData into my own
SimulationData.  The reason for this is to create appropriate routines to
calculate whatever variables we want to extract.
_______________________________________________________________________________
Draw a 2D figure

Take as an argument:
-- An instance of SimulationData
-- An instance of MovieDescription
-- The axes on which to plot

This routine will:
-- Extract the variable to be plotted;
-- Loop over the mask descriptions, call a mask construction routine, and
   compile the masks into a final mask;
-- Construct the imshow plot on the axes;
-- Return the modified axes or just modify them and rely on the call-by-object
   mechanism to give that information back to the calling routine?
_______________________________________________________________________________
Apply a mask

Take as arguments:
-- An instance of SimulationData
-- An instance of MaskDescription

This routine will extract the variable to use for masking, construct the mask
according to the description, and return the mask.
_______________________________________________________________________________







===============================================================================
Basic outline:
_______________________________________________________________________________
-- Driver to parse inputs file in order to construct the MovieDescriptions and
   MaskDescriptions, and obtain a list of output_*/ directories to process.
   This Driver then calls make_all_frames.
-- The make_all_frames routine will perform basic checks, then loop over all
   output_*/ directories, and for each directory will loop over all
   MovieDescriptions to make the individual frames by calling
   make_single_frame.
-- The make_single_frame routine will create a new figure, get the axes for a
   subplot, then call the draw_2D routine.
-- The draw_2D routine will extract the desired variable, construct a
   cumulative mask by looping over the MaskDescriptions and calling make_mask,
   will then apply the mask, then will draw the image and adjust all the Axes
   parameters appropriately.
-- The make_mask routine will construct a mask: an ndarray of bools with the
   same shape as the variable array, with True for values to show and False for
   values to hide.  The cumulative mask will be a logical_and of all masks, so
   that something that is shown (True) in all masks will be shown (True) in the
   cumulative mask, while something that is hidden (False) in any mask will be
   hidden (False) in the cumulative mask.
_______________________________________________________________________________







===============================================================================
Important classes:
_______________________________________________________________________________
NOTES

-- Don't forget to implement the appropriate "magic" methods.  At minimum,
   there should be some sort of string representation.  Possible magic methods
   to be implemented include:
   -- initialization (mainly __init__)
   -- printing (mainly __repr__ and __str__)
   -- copying (__copy__, __deepcopy__)
   -- pickling (I think I won't need this, but passing objects with mpi4py may
      require it if I decided to start doing that)
   -- operators (__eq__, __ne__, __lt__, __le__, __gt__, __ge__)
   -- mathematics (many of these exist, but I probably won't use any)
   -- type conversion (many of these exist, but I probably won't use any)
_______________________________________________________________________________
SimulationData

This class contains the state of the simulation at a given time.  It will hold
the density, momentum, total energy, and their base state values.  It will also
hold the time and the axes.  It requires a constructor that takes a DumsesData
and constructs the SimulationData.  It also will have a collection of methods
to calculate the various quantities.  Each such method will take a mode
parameter to specify whether to calculate the full state or the base state.  A
wrapper routine will take a more detailed mode parameter and the name of the
variable desired.  It will call the appropriate function (the individual
functions can be named as e.g. _density to make them "private").  Any
additional processing will be done in the wrapper; for example, averaging the
full state to get the mean state, or computing the contrast from the full state
and the base state.  The individual quantity functions will use the other
individual quantity functions in order to simplify the calculations and avoid
code redundancy.
_______________________________________________________________________________
MovieDescription

This class contains the description of a movie to be constructed.  It contains:
-- name_stub   : the stub for the image file names
-- file_type   : the extension for the image files
-- variable    : which variable to be plotted
-- mode        : which mode to compute the variable
-- window      : details the upper and lower limits for the plot window along
                 the x and y axes
-- fps         : frames per second
-- make_movie  : flag specifying whether or not to encode images to movie
-- movie_type  : the extension for the movie file
-- final_pause : specifies the duration to pause on the final frame before
                 ending the movie
-- masks       : a list of masks to be applied to the data

In more detail:
-- The frames will be generated as image files according to
      <name_stub>######.<file_type>,
   where ###### is a number derived from the output file that contains the data
   being plotted.  The variables name_stub and file_type must be specified.
-- The variable must be one of the values "known" by the variable selector, and
   must be specified.
-- The mode must be one of:
   -- full state   : the full state of the variable, which is the value
                     operated on by DUMSES; this is the default behavior
   -- base state   : the base state of the variable
   -- perturbation : the full state less the base state
   -- contrast     : the perturbation divided by the base state
   -- mean state   : the mean state, which comes from averaging across
                     horizontal slices
   -- residual     : the full state less the mean state
   -- fraction     : the residual divided by the mean state (this option may
                     need a better name)
-- The window variable is effectively a pair of pairs, specifying the lower and
   upper limits in the x and y directions for a window to be plotted.  To make
   it more eloquent, the window variable is an instance of a Window class,
   which has two variables: x and y.  Both Window.x and Window.y are instances
   of a Limits class, which has two variables: min and max.  Both Limits.min
   and Limits.max can be either None or a floating-point value.  If None, that
   specifies the default value, which is to not trim the data based on that
   limit.  If a float, and the float is beyond the edge of the data, then the
   behavior is expected to fall back to the default behavior and not trim.
-- The fps variable specifies the frame rate as a float giving the frames per
   second.
-- The movie_type is the extension for the movie to be made.  The filename for
   the movie will be <name_stub>.<movie_type>.
-- The final_pause variable is an integer, which specifies the number of
   additional copies of the final frame to be appended to the end of the movie.
-- The masks variable is a list of instances of the DataMask class, which will
   be described below.

If I want to keep it simple, the Movie class will remain simply as a
description of how to construct the movie.  If I want to get fancy, I can start
storing data here, building and storing a cumulative mask, and even setting an
extract_data method.  But since that all depends on the individual frame, and
this is intended to be a description of the whole movie, I don't plan to do so.
_______________________________________________________________________________
MaskDescription

This class contains the description of a mask to be applied to images for a
movie.  It contains:
-- variable  : which variable to be plotted
-- mode      : which mode to compute the variable
-- threshold : the threshold for the mask
-- operator  : the operator for the mask

In more detail:
-- The variable and mode are equivalent to the explanation given for the Movie
   class.
-- The threshold is a float specifying the threshold against which to mask.
-- The operator can be one of '<', '<=', '>', or '>='.  The logic will be that
   we are specifying what to mask; that is, a mask summarized as "ds < 0" means
   that any cell with an entropy perturbation less than zero should be masked,
   leaving cells with an entropy perturbation greater than or equal to zero as
   they were.
